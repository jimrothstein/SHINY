output$COL_VALUE <- renderUI({
x <- iris %>% dplyr::select(!!sym(input$COLUMN))
selectInput("VALUE", "Value", choices = x, selected = x[1])
})
# like a function
filtering_string <- reactive ({
#paste0("dplyr::filter(iris, ", input$COLUMN, " ", input$CONDITION, " ", input$VALUE, ")")
f(ds = iris, quote(call(">", input$Sepal.Length, 7)))
})
output$as_text <- renderText({
filtering_string()
})
# WORKS, but does not work when used in filter_string
f = function(ds, col) ds |> dplyr::filter(!!col)
f(ds=iris, col= quote(Sepal.Length > 7) )
f(ds = iris, quote(call(">", input$Sepal.Length, 7)))
quote(call(">", Sepal.Length, 7))
eval(quote(call(">", Sepal.Length, 7)))
# actual work
output$the_data <- renderTable({
eval(parse(text = filtering_string()))
})
}
# Run the application
shinyApp(ui = ui, server = server)#
# Run the application
shinyApp(ui = ui, server = server)#
## To Run:   Run App, in Rstudio
## REFERENCE:   https://forum.posit.co/t/use-shiny-to-choose-column-equality-and-value-to-filter-by-conditions/47449
library(shiny)
library(tidyverse)
ui <- fluidPage(
# Sidebar:   USER SELECTS
# column input
# boolean input
# and value input
sidebarLayout(
sidebarPanel(
fluidRow(column(4, selectInput("COLUMN", "Filter By:", choices = colnames(iris))),
column(4, selectInput("CONDITION", "Boolean", choices = c("==", "!=", ">", "<"))),
column(4, uiOutput("COL_VALUE")))
),
# Show text generated by sidebar
# use text in tidy pipeline to create subsetted dataframe
mainPanel(
verbatimTextOutput("as_text"),
tableOutput("the_data")
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$COL_VALUE <- renderUI({
x <- iris %>% dplyr::select(!!sym(input$COLUMN))
selectInput("VALUE", "Value", choices = x, selected = x[1])
})
# like a function
filtering_string <- reactive ({
#paste0("dplyr::filter(iris, ", input$COLUMN, " ", input$CONDITION, " ", input$VALUE, ")")
f(ds = iris, quote(call(">", input$Sepal.Length, 7)))
})
output$as_text <- renderText({
filtering_string()
})
# WORKS, but does not work when used in filter_string
f = reactive({function(ds, col) ds |> dplyr::filter(!!col)})
#  f(ds=iris, col= quote(Sepal.Length > 7) )
#  f(ds = iris, quote(call(">", input$Sepal.Length, 7)))
#  quote(call(">", Sepal.Length, 7))
#  eval(quote(call(">", Sepal.Length, 7)))
# actual work
output$the_data <- renderTable({
eval(parse(text = filtering_string()))
})
}
# Run the application
shinyApp(ui = ui, server = server)#
source("~/code/SHINY/app.R")
source("app.R")
dir()
#' This is a super app constructor.
#' @param ... something
#' @return shiny app object
#' @examples
#' if (interactive()) {
#'   my_super_app()
#' }
my_super_app <- function(...) {
...
source("app.R")
shiny::shinyApp(...)
}
#' This is a super app constructor.
#' @param ... something
#' @return shiny app object
#' @examples
#' if (interactive()) {
#'   my_super_app()
#' }
my_super_app <- function(...) {
...
source("app.R")
shiny::shinyApp(ui=ui, server=server)
}
ui
source("app.R")
source("basic_roxy_web/app.R")
#' This is a super app constructor.
#' @param ... something
#' @return shiny app object
#' @examples
#' if (interactive()) {
#'   my_super_app()
#' }
my_super_app <- function(...) {
...
source("basic_roxy_web/app.R")
shiny::shinyApp(ui=ui, server=server)
}
my_super_app(ui= ui, server= sever)
#' This is a super app constructor.
#' @param ... something
#' @return shiny app object
#' @examples
#' if (interactive()) {
#'   my_super_app()
#' }
my_super_app <- function(ui, server) {
...
source("basic_roxy_web/app.R")
shiny::shinyApp(ui=ui, server=server)
}
my_super_app(ui= ui, server= sever)
#' This is a super app constructor.
#' @param ... something
#' @return shiny app object
#' @examples
#' if (interactive()) {
#'   my_super_app()
#' }
my_super_app <- function() {
...
source("basic_roxy_web/app.R")
shiny::shinyApp(ui=ui, server=server)
}
my_super_app()
ui
server
#' @examplesShinyLive
library(mypackage)
#' @examplesShinyLive
interactive <- function() TRUE
{{ next_example }}
# install.packages("pak")
pak::pak("posit-dev/r-shinylive")
system.file("examples", "01_hello", package="shiny") |>
fs::dir_copy("myapp", overwrite = TRUE)
system.file("examples", "01_hello", package="shiny") |>
fs::dir_copy("myapp", overwrite = TRUE)
?system.file
system.file("examples", "01_hello", package="shiny")
fs::dir_copy(path, "myapp", overwrite = TRUE)
path = system.file("examples", "01_hello", package="shiny")
fs::dir_copy(path, "myapp", overwrite = TRUE)
# `convert`
shinylive::export("myapp", "site")
# `convert`
shinylive::export("./shinylive/myapp", "site")
dir()
setwd(shinylive)
setwd("shinylive")
ls
dir()
setwd("myapp")
dir()
setwd("myapp")
setwd("~/code/SHINY/shinylive")
dir()
dir("myapp/ ")
dir("myapp")
getwd()
setwd("myapp")
dir()
cat app.
cat app.R
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)
# `convert` and download web `assets`
shinylive::export("./shinylive/myapp", "site")
dir()
shinylive::export("myapp", "site")
setwd("~/code/SHINY/shinylive")
dir()
# `convert` and download web `assets`
shinylive::export("myapp", "site")
httpuv::runstaticServer()
# `convert` and download web `assets` - wait!
shinylive::export("myapp", "site")
httpuv::runStaticServer("site")
devtools::install_github("https://github.com/atorus-research/datasetjson.git", ref="dev")
library(shiny)
library(ggplot2)
load("movies.RData")
load("./movies.RData")
dir()
load("rstudio_movies_movies_shiny_app/movies.RData")
getwd()
load("rstudio_movies_movies_shiny_app/movies.RData")
load("./rstudio_movies_movies_shiny_app/movies.RData")
dir()
load("./rstudio_movies_movies_shiny_app/movies.RData")
load("~/code/SHINY/rstudio_movies_movies_shiny_app/movies.RData")
load("~/code/SHINY/rstudio_movies_shiny_app/movies.RData")
ui <- fluidPage(
sidebarLayout(
# Inputs: Select variables to plot
sidebarPanel(
# Select variable for y-axis
selectInput(
inputId = "y",
label = "Y-axis:",
choices = c("imdb_rating", "imdb_num_votes", "critics_score", "audience_score", "runtime"),
selected = "audience_score"
),
# Select variable for x-axis
selectInput(
inputId = "x",
label = "X-axis:",
choices = c("imdb_rating", "imdb_num_votes", "critics_score", "audience_score", "runtime"),
selected = "critics_score"
)
),
# Output: Show scatterplot
mainPanel(
plotOutput(outputId = "scatterplot")
)
server <- function(input, output, session) {
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
}
shinyApp(ui = ui, server = server)
server <- function(input, output, session) {
output$scatterplot <- renderPlot({
ggplot(data = movies, aes(x = input$x, y = input$y)) +
geom_point()
})
}
shinyApp(ui = ui, server = server)
server <- function(input, output, session) {
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
}
shinyApp(ui = ui, server = server)
# ratio of critics and audience scores
movies <- movies %>%
mutate(score_ratio = audience_score / critics_score)
movies
movies$score_ratio
lintr:::addin_lint()
runApp('rstudio_movies_shiny_app/app1.R')
styler:::style_active_file()
runApp('rstudio_movies_shiny_app/app1.R')
shinyApp(ui=ui, server=server)
runApp('rstudio_movies_shiny_app/app1.R')
names(movies)
levels(movies$title_type)
runApp('rstudio_movies_shiny_app/app1.R')
movies %>%
dplyr::filter(title_type %in% input$selected_title_type) %>%
group_by(mpaa_rating) %>%
summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())
movies %>%
dplyr::filter(title_type %in% input$selected_title_type) %>%
group_by(mpaa_rating) %>%
summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())
movies %>%
dplyr::filter(title_type %in% input$selected_title_type) %>%
group_by(mpaa_rating) %>%
summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())
library(shiny)
library(ggplot2)
load("~/code/SHINY/rstudio_movies_shiny_app/movies.RData")
# ratio of critics and audience scores
movies <- movies %>%
mutate(score_ratio = audience_score / critics_score)
ui <- fluidPage(
sidebarLayout(
# Inputs: Select variables to plot
sidebarPanel(
# Select variable for y-axis
selectInput(
inputId = "y",
label = "Y-axis:",
choices = c("imdb_rating", "imdb_num_votes", "critics_score", "audience_score", "runtime"),
selected = "audience_score"
),
# Select variable for x-axis
selectInput(
inputId = "x",
label = "X-axis:",
choices = c("imdb_rating", "imdb_num_votes", "critics_score", "audience_score", "runtime"),
selected = "critics_score"
),
# Subset for title types
checkboxGroupInput(
inputId = "selected_title_type",
label = "Select title type:",
choices = levels(movies$title_type),
selected = levels(movies$title_type)
)
), # sidebarPanel
# Output: Show scatterplot
mainPanel(
plotOutput(outputId = "scatterplot"),
# Show data table
tableOutput(outputId = "summarytable")
)
) # end fluidPage
server <- function(input, output, session) {
output$scatterplot <- renderPlot({
ggplot(data = movies, aes_string(x = input$x, y = input$y)) +
geom_point()
})
output$summarytable <- renderTable({
movies %>%
dplyr::filter(title_type %in% input$selected_title_type) %>%
group_by(mpaa_rating) %>%
summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())
},
striped = TRUE,
spacing = "l",
align = "lccr",
digits = 4,
width = "90%",
caption = "Score ratio (audience / critics' scores) summary statistics by MPAA rating."
)
print(movies, n=3)
}
print(movies, n=3)
output
output$summarytable
shinyApp(ui = ui, server = server)
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Old Faithful Geyser Data"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white',
xlab = 'Waiting time to next eruption (in mins)',
main = 'Histogram of waiting times')
})
}
## Only run examples in interactive R sessions
## App 1: Sample usage
shinyApp(
ui = fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
),
server = function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(input$button, {
cat("Showing", input$x, "rows\n")
})
# The observeEvent() above is equivalent to:
# observe({
#    cat("Showing", input$x, "rows\n")
#   }) %>%
#   bindEvent(input$button)
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
)
runApp('observeEvent')
runApp('Repond_once')
install.package("plumber")
pak::pak("plumber")
## Run when push button;  not when slider changes.
## Server reads input$obs;  but does not depend on it.
## Said another way, push button and chain is invalidated, so must recalcualte.
##  but no invalidation when input$obs changes
library(shiny)
ui <- pageWithSidebar(
textInput("x", "x"),
textInput("y", "x")
)
server <- function(input, output) {
output$distPlot <- renderPlot({
# Take a dependency on input$goButton
input$goButton
# Use isolate() to avoid dependency on input$obs
dist <- isolate(rnorm(input$obs))
hist(dist)
})
}
server <- function(input, output) {
output$text <- renderText({
paste("The value of x is", input$x)
})
}
## Run when push button;  not when slider changes.
## Server reads input$obs;  but does not depend on it.
## Said another way, push button and chain is invalidated, so must recalcualte.
##  but no invalidation when input$obs changes
library(shiny)
ui <- pageWithSidebar(
textInput("x", "x"),
textInput("y", "x"),
textOutput("text")
)
runApp('342_isolate2.R')
?textOutput
shinyApp(ui = ui, server = server)
runApp('342_isolate2.R')
## Run when push button;  not when slider changes.
## Server reads input$obs;  but does not depend on it.
## Said another way, push button and chain is invalidated, so must recalcualte.
##  but no invalidation when input$obs changes
library(shiny)
ui <- pageWithSidebar(
textInput("x", "x"),
textInput("y", "y"),
textOutput("text1"),
textOutput("text2")
)
server <- function(input, output) {
output$text1 <- renderText({
paste("The value of x is", input$x)
})
# With isolate - only re-runs when input$y changes, not when input$x changes
output$text2 <- renderText({
paste("Y is", input$y, "and X is", isolate(input$x))
})
}
shinyApp(ui = ui, server = server)
runApp('342_isolate2.R')
?textInput
runApp('342_isolate2.R')
?textOutput
runApp('342_isolate2.R')
